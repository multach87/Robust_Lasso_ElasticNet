---
title: "Data_Generation"
author: "Matt Multach"
date: "`r Sys.Date()`"
output: html_document
#output: 
#       xaringan::infinite_moon_reader:
#              lib_dir: lib
#              highlightStyle: github
#              highlightLines: true
#              countIncrementalSlides: false
#              beforeInit: "macros.js"
#              css: [default, tamu, tamu-fonts]
---

## Preamble

```{r setup, message = FALSE , warning = FALSE , include=FALSE}
knitr::opts_chunk$set(echo = TRUE , eval = TRUE)
```

First, let's load the necessary packages.

```{r libraries}
# This chunk loads the packages used in this workbook
library(xaringan)   # Allows active preview of report in RStudio
library(mvtnorm)    # Generates multivariate-normal data
library(magrittr)   # Used for piping
library(purrr)      # Used for mapping functions efficiently
library(data.table) # For more streamlined data structures
```

And this function generates values from the g-and-h distribution. See CITE for more information.

```{r g-and-h distr function , eval = TRUE}
# Function for generating values from the g-and-h distribution
# # Taken from {CITE ROBUST PACKAGE}
ghdist<-function(n,g=0,h=0){
       #
       # generate n observations from a g-and-h dist.
       #
       x<-rnorm(n)
       if (g>0){
              ghdist<-(exp(g*x)-1)*exp(h*x^2/2)/g
       }
       if(g==0)ghdist<-x*exp(h*x^2/2)
       ghdist
}
```

## Setting up data conditions

### Data.table of unique conditions

The following code chunk generates a data.table with each unique combination of data conditions. The current data will include the following characteristics:

* n = sample size
  * Levels simulated: 38, 75, 150, 300
* p = number of potential predictors
  * Levels simulated: 8, 30
* eta_x = proportion of outlier contamination in the potential predictor variables
  * Levels simulated: 0.0, 0.1, 0.2 (0\%, 10\%, 20\%)
* eta_y = proportion of outlier contamination in response variable
  * Levels simulated: 0.0, 0.1, 0.2 (0\%, 10\%, 20\%)
* g = amount of skew as imposed by the g-and-h distribution
  * Levels simulated: 0.0, 0.2
* h = amount of kurtosis/"peakedness" as imposed by the g-and-h distribution
  * Levels simulated: 0.0, 0.2
  
For the purposes of this example, outlier contamination and skew/kurtosis will be independently varied. Data will not be generated with both contamination and skew/kurtosis. Consequently, there will be a total of 96 unique data conditions.
* Outliers: 4 x 2 x 3 x 3 = 72 conditions
* Skew/Kurtosis: 4 x 2 x 3 = 24 conditions



```{r generate data conditions , eval = T}
# create an empty data.table to fill with data conditions
sim_structure.dt <- setDT(as.data.frame(matrix(ncol = 6 , nrow = 96)))
{
       colnames(sim_structure.dt) <- c("n" , "p" , 
                                    "eta_x" , "eta_y" , 
                                    "g" , "h")
       sim_structure.dt[ , "eta_x"] <- c(rep(c(0.0 , 0.1 , 0.2) , 24) , 
                                         rep(0 , 24))
       sim_structure.dt[ , "eta_y"] <- c(rep(c(rep(0.0 , 3) , rep(0.1 , 3) , 
                                               rep(0.2 , 3)) , 8) , 
                                         rep(0 , 24))
       sim_structure.dt[ , "p"] <- c(rep(c(rep(8 , 9) , rep(30 , 9)) , 4) , 
                                     rep(c(rep(8 , 3) , rep(30 , 3)) , 4))
       sim_structure.dt[ , "n"] <- c(rep(38 , 18) , rep(75 , 18) , 
                                     rep(150 , 18) , rep(300 , 18) , 
                                     rep(38 , 6) , rep(75 , 6) , 
                                     rep(150 , 6) , rep(300 , 6))
       sim_structure.dt[ , "g"] <- c(rep(0 , 72) , rep(c(0.2 , 0.0 , 0.2) , 
                                                       8))
       sim_structure.dt[ , "h"] <- c(rep(0 , 72) , rep(c(0.0 , 0.2 , 0.2) , 
                                                       8))
}
```

And you can take a look at the resulting data.table. This chunk is not evaluated in the report and is for use within RStudio.

```{r view sim conditions , eval = F}
View(sim_structure.dt)
```

### Create repeated data.table

The following chunks will generate a data.table with multiple rows per data condition. Each data condition will therefore have a number of rows equal to the number of simulated iterations. This is primarily used for convenience with the data-generating functions.

The resulting data.table should have a number of rows equal to the number of unique conditions times the number of iterations being simulated for each condition. Here, there are 72 + 24 = 96 unique conditions and we are simulating 500 iterations of each condition, resulting in 48000 total datasets/rows. We are also adding an additional column for the data-generating seed.

```{r create empty data.table}
# create empty df
sim_repped.dt <- setDT(as.data.frame(matrix(ncol = 1 , nrow = (96*500))))
```

Now fill the empty data.table with repeated conditions

```{r fill empty data.table with conditions , warning = F}
# fill empty df with repeated data conditions
for(i in 1:nrow(sim_structure.dt)) {
       sim_repped.dt[ ((500*(i - 1)) + 1): (500*i) , 
                      ':=' (n = sim_structure.dt[i , n] , 
                            p = sim_structure.dt[i , p] , 
                            eta_x = sim_structure.dt[i , eta_x] ,
                            eta_y = sim_structure.dt[i , eta_y] , 
                            g = sim_structure.dt[i , g] , 
                            h = sim_structure.dt[i , h])]
}

```

Finally, generate a seed for each iteration and a tracker number for each iteration. The tracker number will give us a sense of our progress if we run across the entire simulated data. This tracker will simply be the numbers 1 through 48000. Let's also get rid of the blank column from initializing the data.table.

```{r fill seeds column}
# generate random seeds
set.seed(501)
sim_repped.dt[ , seed := runif(n = nrow(sim_repped.dt) , 
                               min = -1e10 , 
                               max = 1e10)]

# generate iteration tracker number
sim_repped.dt[ , tracker := c(1:48000)]

# get rid of blank first column
sim_repped.dt <- sim_repped.dt[ , !1 , with = F]
```

## Generating Simulated data

The chunks in this section will generate the data based on the initial steps conducted above. This function is specific to the data characteristics chosen and varied above. 

### Data-generating function

This function will generate our simulation data on which we will run the models of interest.

NOTE: In its current form, predictor contamination is induced before generating the response values. Consequently, predictor-space outliers will be model-supporting leverage points rather than model-detrimental leverage points.

```{r data-generating function}
data_gen <- function(n , p , eta_x , eta_y , g , h , 
                     seed , tracker) {      
  conditions <- setDT(data.frame(n = n , p = p , 
                                 eta_x = eta_x , eta_y = eta_y , 
                                 g = g , h = h , tracker = tracker , 
                                 seed = seed))

  betas <- matrix(0 , nrow = p , ncol = 1)
  betas[1,1] <- 0.5
  betas[2,1] <- 1.0
  betas[3,1] <- 1.5
  betas[4,1] <- 2.0
       
  # set seed for random process
  seed <- seed                       
       
  #generate covariance matrix
  covar.X <- matrix(rep(0 , p^2) , ncol = p)  
  # # put 1's along diagonal of covariance matrix
  diag(covar.X) <- 1 
       
  # generate uncontam. X values
  X.UC <- rmvnorm(floor((1 - eta_x)*n) , 
                  mean = rep(0 , p) , 
                  sigma = covar.X)
       
  # generate contaminated X/predictor values or 
  # # g-and-h-based X/predictor values
  if(((g == 0) & (h == 0))){
        # if there is predictor contamination, generate the
        # # contaminated values
        if(eta_x > 0) {                             
                X.C <- rmvnorm(ceiling(eta_x*n) , 
                               mean <- rep(10 , p) , 
                               sigma = covar.X)
                X <- rbind(X.UC , X.C)
        # otherwise, set the uncontaminated values to the
        # # full X dataset
        } else {
                X.C <- 0
                X <- X.UC
        }
              
        #generate uncontom. residuals
        err.UC <- rnorm(floor((1-eta_y)*n) , mean = 0 , sd = 1)
        if(eta_y > 0) {  
                # if there is response contamination, generate the
                # # contaminated values
                err.C <- rnorm(ceiling(eta_y*n) , mean = 2 , sd = 5)
                err <- c(err.UC , err.C)
              } else {
                # otherwise, set the uncontaminated values to the
                # # final residuals
                err.c <- 0
                err <- err.UC
              }
       } else if(((g != 0) | (h != 0))) {
         # generates X/predictor values from g-and-h distribution
         # # with no outlier contamination
         X <- X.UC
         err <- ghdist(n = n , g = g , h = h)
       }
  
  #generate Y values from X matrix, 
  # # coefficients vector, and residuals vector
  Y <- X %*% betas[ , 1] + err                                    
  
  # Create list of separate components of generated data   
  combine <- list(conditions = conditions ,
                  tracker = tracker , 
                  seed = seed , 
                  betas = betas , 
                  Y_train = Y[1 : floor((n * .667))] ,
                  Y_hold = Y[floor((n * .667) + 1) : n] , 
                  X_train = setDT(data.frame(X[1 : floor(n * .667) , 
                                               ])) , 
                  X_hold = setDT(data.frame(X[floor((n * .667) + 1) : n , 
                                              ])) , 
                  err = err[floor((n * .667) + 1) : n])        
  
  #save combined list of all generated data
  return(combine)
}
```

Finally, let's map the data-generating function over all data conditions and iterations. Note that I've set "eval = F" for all subsequent chunks. The data file resulting from the chunk below would be nearly 2gb and it's unnecessary to process that for the html walkthrough. This also means that the following chunks won't operate, but I've included them here to show what would follow. Those who are interested in seeing it in action can set the "eval" arguments below to "eval = T". 

```{r generate data , eval = F}
full.data <- sim_repped.dt %>%   
       pmap(data_gen)
```

### Saving the data

If you want to save the resulting data as an .RData file, use the following chunk, specifying the appropriate file path. Note that this chunk will not automatically be evaluated. You must either change the eval argument for the code chunk to "eval = T" or run the code within the chunk independently (after specifying the appropriate path). 

```{r save simulated data , eval = F}
saveRDS(full.data , "FILE/PATH/TO/DESIRED/FOLDER/NAME/fulldata.RData")
```

For use with subsequent demos of the ensemble lasso/elastic net procedure, I will be saving 10/100 random datasets from this full dataset. I've also included the vector of 10/100 random indices and the vector-generating seed for those indices for transparency.

```{r save 10 random datasets , eval = T}
#set the seed
set.seed(501)

#vector of 10 indices
data.10 <- sample(x = c(1:48000) , size = 100 , replace = F)

#save 10 from full data
saveRDS(full.data[data.10] , "/Users/Matt/Desktop/GitHub_Dissertation_Scripts/Robust_Lasso_ElasticNet/Datasets/Testing100.RData")
```

Let's also extract and process a single dataset. 

```{r extract single applied dataset , eval = T}
#set random seed
set.seed(501)

#random index for choosing dataset from full data
data.1 <- sample(x = c(1:48000) , size = 1 , replace = F)

#extract single dataset
testing1 <- full.data[data.1]
```

And now we can save that resulting file.

```{r save single applied dataset , eval = T}
#save applied dataset
saveRDS(testing1 , "/Users/Matt/Desktop/GitHub_Dissertation_Scripts/Robust_Lasso_ElasticNet/Datasets/Testing1.RData")
```

Finally, since I'm going to be creating demos for use with applied datasets, let's make a version that is as close to a real dataset as possible. This mainly means I'm going to strip away the metadata I added for simulation purposes.

```{r applied dataset}
testingapplied <- list(X_train = testing1[[1]][["X_train"]] , 
                       Y_train = testing1[[1]][["Y_train"]] , 
                       X_hold = testing1[[1]][["X_hold"]] , 
                       Y_hold = testing1[[1]][["Y_hold"]])
```

Lastly, we save this "applied" dataset.

```{r save applied dataset}
saveRDS(testingapplied , "/Users/Matt/Desktop/GitHub_Dissertation_Scripts/Robust_Lasso_ElasticNet/Datasets/TestingApplied.RData")
```