---
title: 'K-Fold Subsetting Function Demo'
author: "Matt Multach"
date: "`r Sys.Date()`"
output: 
  bookdown::html_document2:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: false
bibliography: Component_Refs.bib
#output: 
#       xaringan::infinite_moon_reader:
#              lib_dir: lib
#              highlightStyle: github
#              highlightLines: true
#              countIncrementalSlides: false
#              beforeInit: "macros.js"
#              css: [default, tamu, tamu-fonts]
---

## Introduction

This file demonstrates use of a custom function for indexing and splitting a full dataset for k-fold cross-validation.

## Preamble

```{r setup, message = FALSE , warning = FALSE , include=FALSE}
knitr::opts_chunk$set(echo = TRUE , eval = TRUE)
```

First, let's load the necessary packages.

```{r libraries}
# This chunk loads the packages used in this workbook
library(xaringan)   # Allows active preview of report in RStudio
library(mvtnorm)    # Generates multivariate-normal data
library(magrittr)   # Used for piping
library(purrr)      # Used for mapping functions efficiently
library(data.table) # For more streamlined data structures
library(glmnet)     # For general lasso/elastic net functionality
library(hqreg)      # For LAD/Huber-loss regularization with SNCD algorithm
```


---
nocite: |
  @magrittr , @purrr , @xaringan , @mvtnorm , @data.table , @glmnet , @hqreg
---


Let's also load our demo data, which will just be our matricized singular applied dataset.

```{r load synthetic applied dataset}
demo.data <- readRDS("/Users/Matt/Desktop/GitHub_Dissertation_Scripts/Robust_Lasso_ElasticNet/Datasets/TestingApplied_Xmtx.RData")
```

Let's also quickly combine the X and Y list elements into a single object for convenience with the subsetting function. We will put Y into the first column since it corresponds with a left-to-right reading of a regression model.

```{r combine X and Y into single object}
demo.data2 <- setDT(data.frame(cbind(demo.data[["Y"]] , demo.data[["X"]]
                                     )
                               )
                    )
```

## Custom k-fold subsetting function

The chunk below takes a dataset and creates an ordinal variable with *k* levels, corresponding with each of the *k* test sets. The function takes as its arguments:

 * **data** : a dataset to be split into *k* groups
 * **y_col** : an index indicating the column number of the response variable Y in the original dataset
   * Defaults to the first column
 * **x_cols** : indices indicating the column numbers of the predictor variables in the original dataset
   * Defaults to all but the first column
 * **subset_col** : an index for the column number of the subset indicator in the intermediate dataset
   * Defaults to 1 + the number of columns in the original dataset
 * ***k*** : the number of folds for cross-validation
   * Defaults to *k = 5* folds
   * Corresponds with the sample size of the resulting holdout/testing set in the following manner:
   $$
   \begin{equation}
        n_{test} = \text{
                $n_{full}$ $/$ $k$
        }
   \end{equation}
   $$
 * **seed** : a seed for fixing random processes
   * For this function, this is primarily associated with random and unordered assignment of the values of *k* across the full dataset
 * **list** : this argument tells the function if you want the resulting *k*-fold indexed data to be put into list format, with each list element corresponding with one fold *k*
   * This function defaults to *FALSE*, meaning the resulting data will be in matrix/tabular format and will contain a separate column for the index *k*
   * If set to *TRUE*, the resulting list will *not* contain the index variable for *k*, as the list elements themselves correspond with *k*
   * If set to *"traintest"* (in quotes!), the resulting list will instead contain six elements:
     * **"X"** : The training set of predictor values ("X") containing predictor data from *k* - 1 folds/subsets
     * **"Y"** : The training set of response values
     * **"X_Test"** : The holdout/testing set of predictor values
     * **"Y_Test"** : The holdout/testing set of response values ("Y_Test")
     * **"Seed"** : The random-generating seed for the dataset. This is primarily for convenience with the multi-split wrapper function in "CV_Splitting"
     * **"Subsets"** : A *k*-level vector containing the row-ordered subset indicator for the full input dataset
     
Although the chunk isn't printed in the .html walkthrough, the .Rmd file contains additional deprecated versions of the subsetting function for those who are interested. 
 
 * The 08/05/2021 deprecation used *if* / *else if* branching to handle 1D/vector data vs. 2D/tabular data. The current version handles both data inputs without branching. 
 * The 08/06/2021 deprecation only split the resulting data into training/testing/seed elements when setting the "list" argument to "traintest." The current version splits the data into the 6 elements described above.

```{r kfold subsetting function DEPRECATED 08052021 , echo = F , eval = F}
# k-fold subsetting function
kfold_subsetter <- function(data , k = 5 , seed = 7 , list = FALSE) {
        if(length(dim(data)) == 2) { 
                # For 2D data input (matrices, data.tables, dataframes, etc.)
                
                # determine number of subsets which contain an extra element
                # # if n is not evenly divisible by k
                # # # note that this value will be 0 if n/k is evenly divisible
                nsams.large <- nrow(data) %% k
                
                # determine number of smaller subset if n 
                # # is not evenly divisible by k
                # # # note that this will be the total number of samples if n/k is evenly divisible
                nsams.small <- k - nsams.large
                
                # determine sample size of larger subsets if applicable
                samsize.large <- ceiling(nrow(data) / k) * (nsams.large != 0)
                
                # determine sample size of smaller/all subsets
                samsize.small <- floor(nrow(data) / k)
                
                # create indicator for each subset
                subset.indicator <- c(rep( (1 : k) , 
                                           floor(nrow(data) / k)
                                          ) ,
                                      rep( (1 : (nsams.large) ) , 
                                           (1 * (nsams.large != 0) ) 
                                          )
                                      )
                
                # fix random assignment process
                if(seed) {
                        set.seed(seed)
                }
                
                # combine subset indicator with original data  
                newdata <- cbind(data , 
                                 subset = sample(subset.indicator)
                                 )
                
                newdata <- setDT(data.frame(newdata))
                
                # create k-split list if desired
                if(list == TRUE) {
                        newdata <- return(split(newdata , 
                                                newdata[ , "subset"])
                                          )
                } else if(list == "TRAINTEST") {
                        newdata <- return(list(
                                Train = subset(newdata , subset < k) , 
                                Test = subset(newdata , subset %in% k)
                                )
                                )
                } else {
                        newdata <- return(newdata)
                }
        } else if (length(dim(data)) == 0){   
                # for 1D data
                
                # determine number of subsets which contain an extra element
                # # if n is not evenly divisible by k
                # # # note that this value will be 0 if n/k is evenly divisible
                nsams.large <- length(data) %% k
                
                # determine number of smaller subset if n 
                # # is not evenly divisible by k
                # # # note that this will be the total number of samples if n/k is evenly divisible
                nsams.small <- k - nsams.large
                
                # determine sample size of larger subsets if applicable
                samsize.large <- ceiling(length(data) / k) * (nsams.large != 0)
                
                # determine sample size of smaller/all subsets
                samsize.small <- floor(length(data) / k)
                
                # create indicator for each subset
                subset.indicator <- c(rep( (1 : k) , 
                                           floor(length(data) / k)
                                          ) ,
                                      rep( (1 : (nsams.large) ) , 
                                           (1 * (nsams.large != 0) ) 
                                          )
                                      )
                
                # fix random assignment process
                if(seed) {
                        set.seed(seed)
                }
                
                # combine original data and subset indicator
                newdata <- matrix(cbind(data , 
                                        subset = sample(subset.indicator) 
                                        ) ,
                                  ncol = 2
                                  )
                
                # setDT() for splitting step
                newdata <- setDT(data.frame(newdata))
                
                return(newdata)
                
                # create k-split list if desired
                if(list == TRUE) {
                        newdata <- return(split(newdata , 
                                                newdata[ , "subset"])
                                          )
                } else if(list == "TRAINTEST") {
                        newdata <- return(list(
                                Train = subset(newdata , subset < k) , 
                                Test = subset(newdata , subset %in% k)
                                )
                                )
                } else {
                        newdata <- return(newdata)
                }
        }
}
```

```{r kfold subsetting function DEPRECATED2 08062021 , echo = F , eval = F}
# k-fold subsetting function
kfold_subsetter <- function(data , k = 5 , seed = 7 , list = FALSE) {
        # check for string argument in "data"
        if(is.character(data)) {
                data <- eval(parse_expr(data))
        }
        
        # check for data.table and setDT() if not a data.table
        if(!(TRUE %in% (class(data) == "data.table"))) {
                data <- setDT(data.frame(data))
        }
        
        # check for 0 < k <= n/2
        if((k <= 0) | (k > (nrow(data) / 2) ) ) {
                stop("ERROR: number of folds 'k' must be greater than 0 and less than sample size divided by 2")
        }
        
        # determine number of subsets which contain an extra element
        # # if n is not evenly divisible by k
        # # # note that this value will be 0 if n/k is evenly divisible
        nsams.large <- nrow(data) %% k
        
        # determine number of smaller subset if n 
        # # is not evenly divisible by k
        # # # note that this will be the total number of samples if n/k is evenly divisible
        nsams.small <- k - nsams.large
        
        # determine sample size of larger subsets if applicable
        samsize.large <- ceiling(nrow(data) / k) * (nsams.large != 0)
        
        # determine sample size of smaller/all subsets
        samsize.small <- floor(nrow(data) / k)
                
        # create indicator for each subset
        subset.indicator <- c(rep( (1 : k) , 
                                   floor(nrow(data) / k)
                                  ) ,
                              rep( (1 : (nsams.large) ) , 
                                   (1 * (nsams.large != 0) ) 
                                  )
                              )
                
        # fix random assignment process
        if(seed) {
                set.seed(seed)
        }
        
        # combine subset indicator with original data  
        newdata <- cbind(data , 
                         subset = sample(subset.indicator)
                         )
                
        newdata <- setDT(data.frame(newdata))
        
        # create k-split list if desired
        if(list == TRUE) {
                newdata <- return(split(newdata , 
                                        newdata[ , "subset"])
                                  )
        } else if(list == "traintest") {
                newdata <- return(list(
                        Train = subset(newdata , subset < k) , 
                        Test = subset(newdata , subset %in% k) , 
                        Seed = seed
                        )
                        )
        } else {
                newdata <- return(newdata)
        }
}
```


```{r kfold subsetting function}
# k-fold subsetting function
kfold_subsetter <- function(data , y_col = 1 , 
                            x_cols = c(2:ncol(data)) , 
                            subset_col = (ncol(data) + 1) , 
                            k = 5 , seed = 7 , list = FALSE) {
        # check for string object in data argument
        if(is.character(data)) {
                data <- eval(parse_expr(data))
        }
        
        # check for data.table and setDT() if not a data.table
        if(!(TRUE %in% (class(data) == "data.table"))) {
                data <- setDT(data.frame(data))
        }
        
        # check for 0 < k <= n/2
        if((k <= 0) | (k > (nrow(data) / 2) ) ) {
                stop("ERROR: number of folds 'k' must be greater than 0 and less than sample size divided by 2")
        }
        
        # determine number of subsets which contain an extra element
        # # if n is not evenly divisible by k
        # # # note that this value will be 0 if n/k is evenly divisible
        nsams.large <- nrow(data) %% k
        
        # determine number of smaller subset if n 
        # # is not evenly divisible by k
        # # # note that this will be the total number of samples if n/k is evenly divisible
        nsams.small <- k - nsams.large
        
        # determine sample size of larger subsets if applicable
        samsize.large <- ceiling(nrow(data) / k) * (nsams.large != 0)
        
        # determine sample size of smaller/all subsets
        samsize.small <- floor(nrow(data) / k)
                
        # create indicator for each subset
        subset.indicator <- c(rep( (1 : k) , 
                                   floor(nrow(data) / k)
                                  ) ,
                              rep( (1 : (nsams.large) ) , 
                                   (1 * (nsams.large != 0) ) 
                                  )
                              )
                
        # fix random assignment process
        if(seed) {
                set.seed(seed)
        }
        
        # combine subset indicator with original data  
        newdata <- cbind(data , 
                         subset = sample(subset.indicator)
                         )
                
        newdata <- setDT(data.frame(newdata))
        
        # create k-split list if desired
        if(list == TRUE) {
                newdata <- return(split(newdata , 
                                        newdata[ , "subset"])
                                  )
        } else if(list == "traintest") {
                newdata <- return(list(
                    X = subset(newdata[ , c(x_cols, subset_col) , 
                                            with = F] , subset < k) %>%
                        .[ , c(1:8) , with = F] %>%
                        as.matrix() , 
                    Y = subset(newdata[ , c(y_col , subset_col) , 
                                        with = F] , subset < k) %>%
                        .[ , 1 , with = F] %>%
                        as.matrix() , 
                    X_Test = subset(newdata[ , c(x_cols, subset_col) , 
                                            with = F] , subset %in% k) %>%
                        .[ , c(1:8) , with = F] %>%
                        as.matrix() , 
                    Y_Test = subset(newdata[ , c(y_col , subset_col) , 
                                        with = F] , subset %in% k) %>%
                        .[ , 1 , with = F] %>%
                        as.matrix() , 
                    Seed = seed , 
                    Subsets = newdata[ , "subset"]
                        #Train = subset(newdata , subset < k) , 
                        #Test = subset(newdata , subset %in% k) , 
                        #Seed = seed
                        )
                        )
        } else {
                newdata <- return(newdata)
        }
}



```

## Testing the function

Now let's test the function for all three list-splitting options.

### K-fold subset testing: no final data split

First, run the subsetter without splitting the final data.

```{r subset testing nonlist}
nonsplit.data <- kfold_subsetter(data = demo.data2 , k = 5 , 
                                 seed = 7 , list = FALSE)
```

And let's look at the structure of the data.

```{r nonlist str}
str(nonsplit.data)
```

### K-fold subset testing: list containing *k* elements

Next, run the subsetter but splitting by fold index *k*.

```{r subset testing full split}
fullsplit.data <- kfold_subsetter(data = demo.data2 , k = 5 , 
                                  seed = 7 , list = TRUE)
```

And let's look at the structure of the data.

```{r full split str}
str(fullsplit.data)
```

### K-fold subset testing: list containing training and testing elements

Next, run the subsetter but splitting by a single training/testing split.

```{r subset testing traintest split}
trtstsplit.data <- kfold_subsetter(data = demo.data2 , k = 5 , 
                                  seed = 7 , list = "traintest")
```

And let's look at the structure of the data.

```{r traintest split str}
str(trtstsplit.data)
```

## References
