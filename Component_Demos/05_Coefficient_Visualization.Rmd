---
title: 'Visualization Demo'
author: "Matt Multach"
date: "`r Sys.Date()`"
output: 
  bookdown::html_document2:
    toc: true
    toc_depth: 4
    toc_float: true
    number_sections: false
bibliography: Component_Refs.bib
#output: 
#       xaringan::infinite_moon_reader:
#              lib_dir: lib
#              highlightStyle: github
#              highlightLines: true
#              countIncrementalSlides: false
#              beforeInit: "macros.js"
#              css: [default, tamu, tamu-fonts]
---

## Introduction

This document demonstrates the visualization of coefficient inclusion results from our 100-split model data. Graphical objects and manipulation also feature heavily, so we will discuss the many tools I used to present the visuals used.

Due to the multiple tools used to visualize the data effectively, this demo will be a bit longer and more involved than most other demos.

I will not be interpreting the plots produced in this demo. This walkthrough is intended primarily to demonstrate this component of the overall combined model process being proposed and the tools necessary to make this component function. That way, newer users can understand the complex combination of tools that create the larger combined model without detracting from the full walkthrough that these components build towards.

## Preamble

```{r setup, message = FALSE , warning = FALSE , include=FALSE}
knitr::opts_chunk$set(echo = TRUE , eval = TRUE)
```

### Packages

First, let's load the necessary packages. I've also set this code chunk to not print warnings, as they are largely not helpful for the current example.

```{r libraries , warning = FALSE}
# This chunk loads the packages used in this workbook
library(xaringan)     # Allows active preview of report in RStudio
library(magrittr)     # Used for piping
library(purrr)        # Used for mapping functions efficiently
library(data.table)   # For more streamlined data structures
library(glmnet)       # For general lasso/elastic net functionality
library(hqreg)        # For LAD/Huber-loss regularization with SNCD algorithm
library(rlang)        # For parse_expr() to parse data name in k-fold subsetting functions
library(msaenet)      # For the multi-step adaptive elastic net
library(gridExtra)    # For displaying grids of objects
library(grid)         # For creating a title for multiplot grid
library(ggplot2)      # For generating and manipulation graphical objects
```

---
nocite: |
  @magrittr , @purrr , @xaringan , @data.table , @glmnet , @hqreg , @rlang , @msaenet , 
  @gridExtra , @grid , @dplyr , @ggplot2 , @RColorBrewer
---

### Model Loading

Let's load our 100-split model file with "Frequencies" data.table.

```{r load 100-split model RData}
models_freqs <- readRDS("/Users/Matt/Desktop/GitHub_Dissertation_Scripts/Robust_Lasso_ElasticNet/Datasets/models100_plus_freqs.RData")
```



## Visualization

Now we're going to set up our visualizations. There are going to be three sets of plots:
  * Plots of selection frequencies of all predictors by each adaptation
  * Plots of $100/%$ and $0\%$ selection by each adaptation
  * Plots of frequency of $100/%$ and $0/%$ selection of each predictor across adaptations
  
### Visualization Setup

I'm going to create a few practical tools/objects that will be used in our subsequent visualizations.

#### Custom Color Palette

The first thing I'm going to do is create a custom color palette that ensures that the colors are sufficiently distinct. This isn't super necessary for the plots we're generating, but it is a tool I picked up for more intricate plots used in my dissertation and is worth including for interested users. This command just creates a vector of strings that correspond with html color codes.

First, I'm going to make a palette of 11 distinct colors. These are the colors I used when visualizing 11 different lasso and elastic net adaptations in my dissertation. I found that these colors produced pretty meaningful distinctions, so we should be able to sample a practical color palette from these 11 for our purposes. We need two color palettes: one for each of 7 adaptations, and one for each of 8 potential predictors in our models.

```{r make P11 custom color palette}
P11 <- c("#02AD24" , "#FF0000" , "#0000FF" , "#9A4D42" , 
         "#00FFBE" , "#FF00B6" , "#000033" , "#00FF00" ,
         "#FFD300" , "#009FFF" ,  "#783FC1")
```

```{r make P7 from P11}
P7 <- sample(x = P11 , size = 7 , replace = FALSE)
```

```{r make P8 from P11}
P8 <- sample(x = P11 , size = 8 , replace = FALSE)
```

#### Plot legend function

I'm also going to implement a function that stores a plot legend to an object for use with multi-plot displays. I can't remember where I found the function and can't relocate the original post, but I did *not* create this function myself! Should I ever run across this function again in the wild, I'll update this section to give proper credit.

```{r legend function for multi-plots}
g_legend<-function(a.gplot){
       tmp <- ggplot_gtable(ggplot_build(a.gplot))
       leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
       legend <- tmp$grobs[[leg]]
       return(legend)}
```

### Visualization: All Predictors and Adaptations

#### Plot Objects

Now, I'm going to create 7 separate plots. The plots will present the selection frequencies of each potential predictor for each of the 7 lasso/elastic net adaptations included in the combined model.

```{r huberelnet selection frequencies}
huberelnet.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("huberelnet" , "predictor") , ] , 
                     aes(x = predictor , y = huberelnet)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "Adaptive Huber Elastic Net" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8)) +
  scale_fill_manual(values = P8)
```

Let's break down what's happening in the code chunk above. _ggplot2_ works by creating layers of visual elements on top of a visual object. We're going to define a ggplot object named "huberlasso" using the _ggplot()_ function. We then add each subsequent visual layer by taking the initial ggplot object with a '+', and then the next layer.

In defining our ggplot object, we are specifying "aesthetics," in this case the characteristics represented on the x-axis and the variable used to define our y-axis. In order, the subsequent layers:
  * Specify that our plot is a column plot (a bar graph with particular characteristics)
    * We are further specifying that the fill color of each column will vary based on which potential predictor is being represented
  * Specify the plot title and y-axis label 
  * Specify that we do *not* want a plot legend, and that the plot title should be horizontally adjusted and have font size 12
  * Specify that the colors used for filling the columns should come from our custom color palette object
  
Now we're going to do the same for each of the 6 remaining adaptations.

```{r huberlasso selection frequencies}
huberlasso.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("huberlasso" , "predictor") , ] , 
                     aes(x = predictor , y = huberlasso)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "Adaptive Huber Lasso" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

```{r ladelnet selection frequencies}
ladelnet.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("ladelnet" , "predictor") , ] , 
                     aes(x = predictor , y = ladelnet)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "Adaptive LAD Elastic Net" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

```{r ladlasso selection frequencies}
ladlasso.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("ladlasso" , "predictor") , ] , 
                     aes(x = predictor , y = ladlasso)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "Adaptive LAD Lasso" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

```{r msak10 selection frequencies}
msak10.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("msak10" , "predictor") , ] , 
                     aes(x = predictor , y = msak10)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "10-Step Adaptive Elastic Net" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

```{r msak3 selection frequencies}
msak3.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("msak3" , "predictor") , ] , 
                     aes(x = predictor , y = msak3)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "3-Step Adaptive Elastic Net" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

```{r msak5 selection frequencies}
msak5.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("msak5" , "predictor") , ] , 
                     aes(x = predictor , y = msak5)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "5-Step Adaptive Elastic Net" ,
       y = "Frequency") + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

I'm also going to create a blank ggplot object to help with arranging our multi-plot display.

```{r blank ggplot}
blank.pl <- ggplot() +
  geom_blank() + 
  theme_minimal()
```

#### Create Plot Legend

Let's also create the legend for this multi-plot. Since all refer to the same predictors, we can just pull this from a single adaptation's plot object. First, though, we need to create a plot object that includes a legend.

```{r plot object for first multiplot legend}
msak5.l <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("msak5" , "predictor") , ] , 
                     aes(x = predictor , y = msak5)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "5-Step Adaptive Elastic Net" ,
       y = "Frequency") + 
  theme(plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.title.x = element_text(size = 8) , 
        axis.title.y = element_text(size = 8)) +
  scale_fill_manual(values = P8)
```

```{r legend for first multiplot}
plotA.legend <- g_legend(msak5.l)
```

#### Put Plot Objects Together

Lastly (for this plot), we're going to create a grid arrangement of our plots so that they are all presented in a simultaneous object.

```{r multiplotA arrange}
plotA <- grid.arrange(arrangeGrob(huberelnet.pl , blank.pl , huberlasso.pl , 
                                  ladelnet.pl , blank.pl , ladlasso.pl , 
                                  msak3.pl , msak5.pl , msak10.pl , 
                                  nrow = 3) , 
                       arrangeGrob(plotA.legend) , 
                      ncol = 2 , widths = c(200 , 40) , 
                      top = textGrob("Predictor Selection Frequency by Lasso/Elastic Net Adaptation Across All 100 Data Splits"))
```



### Visualization: All/None Predictor Selection by Adaptation

#### Plot Objects

Now, I'm going to create 2 separate. One plot will display the number of predictors selected into $100\%$ of models for each of the 7 adaptations, while the second plot will display similar information for number of predictors selected into *no* models by adaptation. We can mostly just take our previous code and make slight changes, but the structure of creating these objects is largely the same. 

Two noteworthy additions/changes were made, though. First, an additional visual layer was specified by _coord_cartesian()_, which explicitly controls range of y values displayed on the plots. I've also angled the axis ticks for the x-axis to facilitate a later plot. This is specified by the argument "axis.text.x" in the _theme()_ layer. I've also vertically- and horizontally-justified these labels in the same argument to prevent collision with the plots themselves.

Notably, we only need two plots this time.

```{r adaptation 100 plot}
adapt100.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Adaptation"]][ , c("all" , "method") , ] , 
                     aes(x = method , y = all)) +
  geom_col(aes(fill = method)) + 
  labs(title = "100% Selection" ,
       y = "100% Selection (out of 7)" , 
       x = "Adaptation") + 
  coord_cartesian(ylim = c(0 , 5)) + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.text.x = element_text(hjust = 1 , 
                                   vjust = 1 , 
                                   angle = 45)) +
  scale_fill_manual(values = P7)
```

```{r adaptation 0 plot}
adapt0.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Adaptation"]][ , c("none" , "method") , ] , 
                     aes(x = method , y = none)) +
  geom_col(aes(fill = method)) + 
  labs(title = "0% Selection" ,
       y = "0% Selection (out of 7)" , 
       x = "Adaptation") + 
  coord_cartesian(ylim = c(0 , 5)) + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.text.x = element_text(hjust = 1 , 
                                   vjust = 1 , 
                                   angle = 45)) +
  scale_fill_manual(values = P7)
```

#### Create Plot Legend

Let's also create the legend for this multi-plot after creating an analogous plot with the legend included.

```{r plot object for multiplotB legend}
adapt100.l <- ggplot(data = models_freqs[["Frequencies"]][["By_Adaptation"]][ , c("all" , "method") , ] , 
                     aes(x = method , y = all)) +
  geom_col(aes(fill = method)) + 
  labs(title = "100% Selection" ,
       y = "100% Selection (out of 7)" , 
       x = "Adaptation") + 
  coord_cartesian(ylim = c(0 , 5)) + 
  theme(plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.text.x = element_text(angle = 45)) +
  scale_fill_manual(values = P7)
```

```{r legend for multiplotB}
plotB.legend <- g_legend(adapt100.l)
```


#### Put Plot Objects Together

```{r multiplotB arrange}
plotB <- grid.arrange(arrangeGrob(adapt0.pl , 
                                  adapt100.pl , 
                                  nrow = 2) , 
                       arrangeGrob(plotB.legend) , 
                      ncol = 2 , widths = c(200 , 40) , 
                      top = textGrob("0% and 100% Selection Frequency by Lasso/Elastic Net Adaptation"))
```



### Visualization: All/None Predictor Selection by Predictor

#### Plot Objects

I'm going to analogous plots to those in the previous subsection. This time, however, the plots look at the number of adaptations for which a given predictor was *always* or *never* selected across the 100 data splits. 

```{r predictor 100 plot}
pred100.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("all" , "predictor") , ] , 
                     aes(x = predictor , y = all)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "100% Selection" ,
       y = "100% Selection (out of 100)" , 
       x = "Predictor") + 
  coord_cartesian(ylim = c(0 , 5)) + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.text.x = element_text(angle = 45)) +
  scale_fill_manual(values = P8)
```

```{r predictor 0 plot}
pred0.pl <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("none" , "predictor") , ] , 
                     aes(x = predictor , y = none)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "0% Selection" ,
       y = "0% Selection (out of 100)" , 
       x = "Predictor") + 
  coord_cartesian(ylim = c(0 , 5)) + 
  theme(legend.position = "none" , 
        plot.title = element_text(hjust = 0.5 , 
                                  size = 8) , 
        axis.text.x = element_text(angle = 45)) +
  scale_fill_manual(values = P8)
```

#### Create Plot Legend

Let's also create the legend for this multi-plot after creating an analogous plot with the legend included.

```{r plot object for multiplotC}
pred100.l <- ggplot(data = models_freqs[["Frequencies"]][["By_Predictor"]][ , c("all" , "predictor") , ] , 
                     aes(x = predictor , y = all)) +
  geom_col(aes(fill = predictor)) + 
  labs(title = "100% Selection" ,
       y = "100% Selection (out of 7)" , 
       x = "Predictor") + 
  coord_cartesian(ylim = c(0 , 5)) + 
  theme(plot.title = element_text(hjust = 0.5 , 
                                  size = 8)) +
  scale_fill_manual(values = P8)
```

```{r legend for multiplotC legend}
plotC.legend <- g_legend(pred100.l)
```


#### Put Plot Objects Together

```{r multiplotC arrange}
plotC <- grid.arrange(arrangeGrob(pred0.pl , 
                                  pred100.pl , 
                                  nrow = 2) , 
                       arrangeGrob(plotB.legend) , 
                      ncol = 2 , widths = c(200 , 40) , 
                      top = textGrob("0% and 100% Selection Frequency by Potential Predictor"))
```


### One Last Visualization

I'm going to combine combine the elements of the last two plots into a single plot to finalize this walkthrough and emphasize some of the visual display tools at our disposal in R.

First, though, I would like you to attempt this on your own. There is a hint below as to how I am going to accomplish this, although multiple formats could be used.

\newpage

#### Hint

I'm going to take the four previous plot objects (corresponding to $100\%$ and $0\%$ selection frequency by predictor and adaptation) and the two previous legend objects and use grid.arrange to make two columns: a 4x4 grid of our 4 plots, and a 2x1 grid of our two legends. I'm then going to adjust the overall plot title accordingly.

\newpage

#### An extra page break so you don't mistakenly see the answer if you're trying to avoid it!

\newpage

#### Combined 100/0 Multiplot

```{r multiplotD arrange}
plotD <- grid.arrange(arrangeGrob(adapt0.pl , adapt100.pl ,
                                  pred0.pl , pred100.pl , 
                                  nrow = 2) , 
                       arrangeGrob(plotB.legend , 
                                   plotC.legend , 
                                   nrow = 2) , 
                      ncol = 2 , widths = c(200 , 40) , 
                      top = textGrob("0% and 100% Selection Frequency by Adaptation (top row) and Potential Predictor (bottom row)" , 
                                     gp=gpar(fontsize=10,font=3)))
```

## References
